---
# Dynamically populate the host groups with host vars
- hosts:
   localhost
  gather_facts: no
  tasks:
     # clienthosts group
    - shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json"
      register: output
      with_items: groups['clienthost-managers']
      delegate_to: localhost
    - add_host: name="{{ item.stdout | from_json | attr('get')('ClientInstancePublicIp') }}" group=clienthosts
        ClientInstancePublicIp="{{ item.stdout | from_json | attr('get')('ClientInstancePublicIp') }}"
        ClientInstancePrivateIp="{{ item.stdout | from_json | attr('get')('ClientInstancePrivateIp') }}"
      with_items: output['results']

# Wait for hosts to become ready
- hosts: clienthosts
  gather_facts: False
  sudo: false
  tasks:
    - name: Wait for ssh port to open
      local_action: wait_for host={{ inventory_hostname }} search_regex=OpenSSH delay=10 port=22
  

# Now launch containers inside them
# Amazon amis we're using already have docker installed so no need for install_docker role
- hosts: clienthosts
  gather_facts: False
  vars:
    ansible_sudo: True
  roles:
    - client

# Modify Jmeter Scripts to hit vips or wideips
# Means replacing hostnames with BIGIP-VIPs jmeter files themselves (No DNS requirement)

#ex.
#    - replace: dest=~/simple-load-generation.jmx regexp='demo.example.com' replace='{{VIP}}'
# OR
# modify /etc/resolv.conf to resolve example.com at GTM Listener
# so first need to load GTM listeners again (Vip1)

- hosts: localhost
  vars:
    vip_id: "Vip1"
  gather_facts: no
  tasks:
    - shell: "cat ~/vars/f5aws/env/{{ env_name }}/{{ item }}.json"
      register: output
      with_items: groups['gtm-managers']

    - add_host: group=gtms name="{{ item.stdout | from_json | attr('get')('ManagementInterfacePublicIp') }}"
        ExternalInterfacePublicIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePublicIp') }}"
        ExternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('ExternalInterfacePrivateIp') }}"
        InternalInterfacePrivateIp="{{ item.stdout | from_json | attr('get')('InternalInterfacePrivateIp') }}"
        VipAddress="{{ item.stdout | from_json | attr('get')('Vip1') }}"
        ansible_ssh_user="admin"
      with_items: output['results']

    - debug: var=groups['gtms']

#Then modify Nameservers 
- hosts: clienthosts
  gather_facts: False
  vars:
    ansible_sudo: True
  tasks:
    - name: Grab number of existing name servers
      shell: "egrep -c nameserver /etc/resolv.conf"
      ignore_errors: true
      register: nameserver_count

    - debug: var=nameserver_count.stdout

    # Future: Need to place GTMs first. 
    # ex. echo "$(echo 'task goes here' | cat - todo.txt)" > todo.txt
    - name: Add example.com nameservers to /etc/resolv.conf if just default one nameserver
      #shell: "echo 'nameserver {{hostvars[item]['VipAddress']}}' >> /etc/resolv.conf"
      #shell: "echo $(echo 'nameserver {{hostvars[item]['VipAddress']}}\n' | cat - /etc/resolv.conf ) >> /etc/resolv.conf"
      replace: dest=/etc/resolv.conf regexp='OVERWRITTEN' replace='OVERWRITTEN\nnameserver {{hostvars[item]['VipAddress']}}'
      with_items: groups['gtms'] 
      when: nameserver_count.stdout|int < 2

### Example Default /etc/resolv.conf in AWS ####

# ubuntu@ip-172-16-13-4:~$ cat /etc/resolv.conf
# # Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
# #     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
# nameserver 172.16.0.2
# search ec2.internal
#  
# More permanent way to set new nameservers   
#/etc/resolvconf/resolv.conf.d/base
#sudo resolvconf -u

# Upload & launch Jmeter test client in background
- hosts: clienthosts
  gather_facts: False
  tasks:

    - name: Copy over simple load generation jmeter script
      copy: src=../roles/client/files/simple-load-generation.jmx dest=~/

    - name: Copy over attack jmeter script
      copy: src=../roles/client/files/attack-site.jmx dest=~/
# 
#    - name: Launch jmeter script in background
#      shell: nohup jmeter -n -t ~/simple-load-generation.jmx &
# 

